{% extends "main_app/header.html" %}


{%block title %} Graph {% endblock %}

{%block extra_headers %}

    {% load static %}
    <script type="text/javascript" src="{% static 'js/three.js' %}"></script>
    <script type="text/javascript" src="{% static 'js/OrbitControls.js' %}"></script>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>


{%endblock%}


{% block content %}

    <script>
        function axes_lines(){
            axes_size_start  = 0;
            axes_size_end  = ( camera.position.x + camera.position.y + camera.position.z ) / 3.0;

            line_width = 200 ;

            var x_axis_material = new THREE.LineBasicMaterial( 
                { 
                    color: 0xff0000,
                    linewidth: line_width,
                } 
            );
            x_axis_material.depthWrite = false;
            var x_axis_geometry = new THREE.Geometry();

            x_axis_geometry.vertices.push( new THREE.Vector3( axes_size_start, 0, 0 ))
            x_axis_geometry.vertices.push( new THREE.Vector3( axes_size_end, 0, 0 ))
            var x_axis_line = new THREE.Line( x_axis_geometry, x_axis_material );

            var y_axis_material = new THREE.LineBasicMaterial( 
                { 
                    color: 0x00ff00,
                    linewidth: line_width,
                } 
            );
            y_axis_material.depthWrite = false;
            var y_axis_geometry = new THREE.Geometry();

            y_axis_geometry.vertices.push( new THREE.Vector3( 0, axes_size_start, 0 ))
            y_axis_geometry.vertices.push( new THREE.Vector3( 0, axes_size_end, 0 ))
            var y_axis_line = new THREE.Line( y_axis_geometry, y_axis_material );

            var z_axis_material = new THREE.LineBasicMaterial( 
                { 
                    color: 0x0000ff,
                    linewidth: line_width,
                } 
            );
            z_axis_material.depthWrite = false;
            var z_axis_geometry = new THREE.Geometry();

            z_axis_geometry.vertices.push( new THREE.Vector3( 0, 0, axes_size_start ))
            z_axis_geometry.vertices.push( new THREE.Vector3( 0, 0, axes_size_end ))
            var z_axis_line = new THREE.Line( z_axis_geometry, z_axis_material );

            return [x_axis_line, y_axis_line, z_axis_line];
        }

        function make_cube(){
            var geometry = new THREE.BoxGeometry( 1,1,1 );
            var material = new THREE.LineBasicMaterial( {color : 0x00ff00 });
            var cube = new THREE.Mesh( geometry, material );
            return cube
        }

        function createGraph(f)
        {
            // xRange = xMax - xMin;
            // yRange = yMax - yMin;
            // zFunc = Parser.parse(zFuncText).toJSFunction( ['x','y'] );
            var x_max = 0;
            var x_min = 0;
            var z_max = 0;
            var z_min = 0;

            x_max = 10;
            x_min = -x_max

            x_range = x_max - x_min;

            z_max = 10;
            z_min = -z_max

            z_range = z_max - z_min;

            meshFunction = function(u, v, vertex) 
            {

                x = u*x_range + x_min;
                z = v*z_range + z_min;

                y = f(x,z);

                vertex.x = x;
                vertex.y = y;
                vertex.z = z;
                // x = xRange * x + xMin;
                // y = yRange * y + yMin;
                // var z = zFunc(x,y); //= Math.cos(x) * Math.sqrt(y);
                // if ( isNaN(z) )
                //     return new THREE.Vector3(0,0,0); // TODO: better fix
                // else
                // return new THREE.Vector3(x, y, z);
            };
            
            // true => sensible image tile repeat...
            graphGeometry = new THREE.ParametricGeometry( meshFunction, 20, 20);
            var material = new THREE.MeshBasicMaterial( { color: "rgb(100,50,50)", side:THREE.DoubleSide , transparency:true,opacity:0.5 } );
            ///////////////////////////////////////////////
            // calculate vertex colors based on Z values //
            ///////////////////////////////////////////////
            graphGeometry.computeBoundingBox();
            zMin = graphGeometry.boundingBox.min.z;
            zMax = graphGeometry.boundingBox.max.z;
            zRange = zMax - zMin;
            var color, point, face, numberOfSides, vertexIndex;
            // faces are indexed using characters
            var faceIndices = [ 'a', 'b', 'c', 'd' ];
            // first, assign colors to vertices as desired
            for ( var i = 0; i < graphGeometry.vertices.length; i++ ) 
            {
                point = graphGeometry.vertices[ i ];
                color = new THREE.Color( 0x0000ff );
                color.setHSL( 0.7 * (zMax - point.z) / zRange, 1, 0.5 );
                graphGeometry.colors[i] = color; // use this array for convenience
            }
            // copy the colors as necessary to the face's vertexColors array.
            for ( var i = 0; i < graphGeometry.faces.length; i++ ) 
            {
                face = graphGeometry.faces[ i ];
                numberOfSides = ( face instanceof THREE.Face3 ) ? 3 : 4;
                for( var j = 0; j < numberOfSides; j++ ) 
                {
                    vertexIndex = face[ faceIndices[ j ] ];
                    face.vertexColors[ j ] = graphGeometry.colors[ vertexIndex ];
                }
            }
            ///////////////////////
            // end vertex colors //
            ///////////////////////
            // material choices: vertexColorMaterial, wireMaterial , normMaterial , shadeMaterial
            
            
            graphGeometry.computeFaceNormals();
            graphGeometry.computeVertexNormals();
            
            graphMesh = new THREE.Mesh( graphGeometry, wireMaterial);


            // graphMesh.doubleSided = true;
            return graphMesh;
        }

        function make_mesh(f, max_points=10){
            var face_color = new THREE.Color( "rgb(255,0,0)" ); 

            var geometry = new THREE.Geometry();
            vertices = [];
            var t0 = performance.now();
            for (var x = -max_points; x <= max_points; x=x+0.1) {
                for (var y = -max_points; y <= max_points; y=y+0.1) {
                    z = f(x,y);
                    vertices.push([x,z,y]);

                }   
            }

            vertices.sort( function (v_a,v_b) {
                return v_b[1] - v_a[1]  ; // sort using the y coordinates
            })

            a = 0;
            vertices.forEach( function (vertex, index) {
                // console.log(vertex, index);
                geometry.vertices.push( new THREE.Vector3(vertex[0],vertex[1],vertex[2]) );

                // if (a % 2 == 0){
                //     console.log('connecting faces : '+a+' '+(a+1)+' '+ (a+2));
                //     // if this is the third vertex...
                //     var face = new THREE.Face3 ( a, a+1, a+2 );
                //     face.color = face_color;
                //     geometry.faces.push( face );
                // }

                // a += 1;
                }
            );

            geometry.computeBoundingBox();
            // vertices.forEach( function ( vertex, index) {
            //     return verte
            // })

            var t1 = performance.now();
            console.log("f(x,y) took " + (t1 - t0) + " milliseconds.");
            return geometry;
    
            // mesh = THREE.Mesh( geometry );
            // return mesh;

        }

        function setup_scene(){
            var scene = new THREE.Scene();
            var FOV = 75;
            var ASPECT_RATIO = window.innerWidth / window.innerHeight;
            
            // var camera = new THREE.PerspectiveCamera( FOV, ASPECT_RATIO, 0.1, 1000)
            var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
            
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight);
            document.body.appendChild( renderer.domElement );

            // things that don't belong here...

            var axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );

            var controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.mouseButtons.RIGHT = null;  // disable pan
            controls.enableDamping = true ;
            return [scene, camera, renderer, controls]

        }

        function f(x,y){
            return x**2+y**2;
        }

        var onCameraChange = function(){
                // console.log("camera changed " + camera.position);
                console.log(x_axis_line.geometry.vertices);
                x_axis_line.geometry.vertices[1].x = camera.position.x;
                y_axis_line.geometry.vertices[1].y = camera.position.y;
                z_axis_line.geometry.vertices[1].z = camera.position.z;

                x_axis_line.geometry.verticesNeedUpdate = true;
                y_axis_line.geometry.verticesNeedUpdate = true;
                z_axis_line.geometry.verticesNeedUpdate = true;



        }


        var [scene, camera, renderer, controls] = setup_scene();

        controls.addEventListener("change", onCameraChange);

        var [x_axis_line, y_axis_line, z_axis_line] = axes_lines();
        var cube = make_cube();


        var uniforms = {
            colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
            colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}
         }
        camera.position.set(5, 5, 5);
        camera.lookAt( 0, 0, 0 );

        var mesh = createGraph(f);

        scene.add( mesh );

        scene.add( x_axis_line );
        scene.add( y_axis_line );
        scene.add( z_axis_line );

        // scene.add( make_mesh() );
        // scene.add( cube );

        var a = 0;

        var previous_position = camera.position;
        function animate(){
            if (
                (
                    (camera.position.x - previous_position.x) > 1
                ) ||
                (
                    (camera.position.y - previous_position.y) > 1
                ) ||
                (
                    (camera.position.z - previous_position.z) > 1
                )||true
            ){
            }

            requestAnimationFrame( animate );
            controls.update();
            renderer.render( scene, camera );
        }
        animate();

    </script>
<!--
    {% for eq in equations.values %}
        <h1> {{eq}}</h1> <br />
    {%endfor%}
-->


{% endblock %}